# 平台适配案例

<cite>
**本文档引用的文件**
- [DomRenderer.ts](file://packages/runtime-dom/src/DomRenderer.ts)
- [factory.ts](file://packages/runtime-ssr/src/factory.ts)
- [SSRDriver.ts](file://packages/runtime-ssr/src/server/SSRDriver.ts)
- [HydrateDriver.ts](file://packages/runtime-ssr/src/client/HydrateDriver.ts)
- [schema.ts](file://packages/runtime-core/src/renderer/schema.ts)
- [attributes.ts](file://packages/runtime-dom/src/types/attributes.ts)
- [style.ts](file://packages/runtime-core/src/utils/style.ts)
- [element.ts](file://packages/runtime-core/src/types/element.ts)
- [element.ts](file://packages/runtime-core/src/vnode/creator/element.ts)
- [constrants.ts](file://packages/runtime-ssr/src/common/constrants.ts)
</cite>

## 目录
1. [项目结构](#项目结构)
2. [核心组件](#核心组件)
3. [浏览器环境下的DomRenderer实现](#浏览器环境下的domrenderer实现)
4. [服务端渲染的空渲染器模式](#服务端渲染的空渲染器模式)
5. [SVG专用渲染器构建](#svg专用渲染器构建)
6. [跨平台适配模式总结](#跨平台适配模式总结)

## 项目结构

```mermaid
graph TD
subgraph "核心包"
runtime-core["runtime-core\n(核心运行时)"]
responsive["responsive\n(响应式系统)"]
runtime-drivers["runtime-drivers\n(驱动器)"]
end
subgraph "平台适配包"
runtime-dom["runtime-dom\n(DOM渲染器)"]
runtime-ssr["runtime-ssr\n(SSR服务端渲染)"]
end
subgraph "工具包"
utils["utils\n(工具函数)"]
end
subgraph "入口包"
vitarx["vitarx\n(主包)"]
end
runtime-core --> runtime-dom
runtime-core --> runtime-ssr
runtime-core --> runtime-drivers
responsive --> runtime-core
utils --> runtime-core
utils --> responsive
runtime-dom --> vitarx
runtime-ssr --> vitarx
```

**图源**
- [DomRenderer.ts](file://packages/runtime-dom/src/DomRenderer.ts)
- [factory.ts](file://packages/runtime-ssr/src/factory.ts)
- [SSRDriver.ts](file://packages/runtime-ssr/src/server/SSRDriver.ts)

**节源**
- [DomRenderer.ts](file://packages/runtime-dom/src/DomRenderer.ts)
- [factory.ts](file://packages/runtime-ssr/src/factory.ts)

## 核心组件

本项目的核心组件包括DomRenderer、SSR渲染器、驱动器系统和响应式系统。DomRenderer是浏览器环境下的主要渲染器，负责DOM操作和渲染。SSR渲染器在服务端通过Proxy实现空渲染器模式，避免DOM操作。驱动器系统负责节点的挂载、更新和卸载。响应式系统提供数据绑定和状态管理功能。

**节源**
- [DomRenderer.ts](file://packages/runtime-dom/src/DomRenderer.ts)
- [SSRDriver.ts](file://packages/runtime-ssr/src/server/SSRDriver.ts)
- [responsive](file://packages/responsive)

## 浏览器环境下的DomRenderer实现

DomRenderer是浏览器环境下的核心渲染器，实现了HostRenderer接口，负责DOM元素的创建、更新和销毁。它支持SVG元素处理、属性批量设置和事件代理机制。

### SVG元素处理

DomRenderer通过命名空间处理SVG元素。当创建SVG元素时，使用`createElementNS`方法指定SVG命名空间。`isSVGElement`标志用于标识SVG元素及其子元素。

```mermaid
sequenceDiagram
participant VNode as 虚拟节点
participant Renderer as DomRenderer
participant DOM as DOM API
VNode->>Renderer : createRegularElementVNode('svg')
Renderer->>Renderer : 设置 isSVGElement = true
Renderer->>Renderer : 递归传播SVG命名空间
Renderer->>DOM : createElementNS('http : //www.w3.org/2000/svg', 'svg')
DOM-->>Renderer : SVG元素实例
Renderer-->>VNode : 返回创建的元素
```

**图源**
- [DomRenderer.ts](file://packages/runtime-dom/src/DomRenderer.ts#L64-L74)
- [element.ts](file://packages/runtime-core/src/vnode/creator/element.ts#L55-L64)

### 属性批量设置

DomRenderer提供了`setAttributes`方法用于批量设置元素属性。该方法遍历属性对象，为每个属性调用`setAttribute`方法。

```mermaid
flowchart TD
Start([开始批量设置属性]) --> Loop["遍历属性对象"]
Loop --> CheckKey{"检查属性键"}
CheckKey --> |事件属性| HandleEvent["处理事件监听器"]
CheckKey --> |样式属性| HandleStyle["处理样式"]
CheckKey --> |类属性| HandleClass["处理CSS类"]
CheckKey --> |data属性| HandleData["处理data-*属性"]
CheckKey --> |xlink属性| HandleXLink["处理xlink:*属性"]
CheckKey --> |直接属性| TryDirect["尝试直接设置属性"]
CheckKey --> |其他属性| SetAttribute["使用setAttribute"]
HandleEvent --> Next
HandleStyle --> Next
HandleClass --> Next
HandleData --> Next
HandleXLink --> Next
TryDirect --> Next
SetAttribute --> Next
Next --> Loop
Loop --> End([完成批量设置])
```

**图源**
- [DomRenderer.ts](file://packages/runtime-dom/src/DomRenderer.ts#L319-L324)
- [attributes.ts](file://packages/runtime-dom/src/types/attributes.ts)

### 事件代理机制

DomRenderer实现了完整的事件代理机制，支持事件选项如capture、once和passive。事件名称通过`extractEventOptions`方法解析，提取事件类型和选项。

```mermaid
sequenceDiagram
participant Element as DOM元素
participant Renderer as DomRenderer
participant Handler as 事件处理器
Element->>Renderer : setAttribute('onClickCapture', handler)
Renderer->>Renderer : extractEventOptions('onClickCapture')
Renderer->>Renderer : 返回{event : 'click', options : {capture : true}}
Renderer->>Element : addEventListener('click', handler, {capture : true})
Element->>Handler : 触发事件
Handler-->>Element : 处理事件
```

**图源**
- [DomRenderer.ts](file://packages/runtime-dom/src/DomRenderer.ts#L487-L496)
- [DomRenderer.ts](file://packages/runtime-dom/src/DomRenderer.ts#L521-L538)

**节源**
- [DomRenderer.ts](file://packages/runtime-dom/src/DomRenderer.ts)

## 服务端渲染的空渲染器模式

服务端渲染通过Proxy实现空渲染器模式，避免在服务端执行DOM操作。

### SSR环境检测

通过`__IS_SERVER__`常量检测是否在服务端运行：

```mermaid
flowchart TD
Start([启动应用]) --> CheckEnv["检查 process 对象"]
CheckEnv --> |存在且为Node环境| SetServer["设置 __IS_SERVER__ = true"]
CheckEnv --> |浏览器环境| SetClient["设置 __IS_SERVER__ = false"]
SetServer --> CreateProxy["创建空渲染器Proxy"]
SetClient --> CreateDomRenderer["创建DomRenderer实例"]
CreateProxy --> Register["注册渲染器"]
CreateDomRenderer --> Register
Register --> End([完成渲染器注册])
```

**图源**
- [constrants.ts](file://packages/runtime-ssr/src/common/constrants.ts)
- [factory.ts](file://packages/runtime-ssr/src/factory.ts)

### Proxy空渲染器

在服务端，渲染器被替换为Proxy对象，所有方法调用都会抛出错误：

```mermaid
classDiagram
class HostRenderer {
+createElement()
+isContainer()
+createFragment()
+createText()
+isElement()
+remove()
+insertBefore()
+replace()
+appendChild()
+addStyle()
+removeStyle()
+getBoundingClientRect()
+setClass()
+addClass()
+removeClass()
+requestAnimationFrame()
+cancelAnimationFrame()
+setAttribute()
+setAttributes()
+removeAttribute()
+setText()
+querySelector()
+querySelectorAll()
+getParentElement()
}
class EmptyRendererProxy {
+get(target, property, receiver)
+apply(target, thisArg, argumentsList)
}
EmptyRendererProxy --> HostRenderer : "实现"
EmptyRendererProxy : 拦截所有方法调用
EmptyRendererProxy : 抛出"不支持服务端"错误
```

**图源**
- [factory.ts](file://packages/runtime-ssr/src/factory.ts#L8-L14)

### SSR驱动器

SSR驱动器负责服务端的节点渲染，不执行DOM操作，只处理虚拟节点的渲染逻辑：

```mermaid
sequenceDiagram
participant Node as 虚拟节点
participant Driver as SSRDriver
participant App as SSRApp
Node->>Driver : render()
Driver->>Driver : 检查节点类型
Driver->>Driver : isContainerNode?
Driver->>Driver : isStatelessWidgetNode?
Driver->>Driver : isStatefulWidgetNode?
Driver->>App : 收集异步任务
Driver-->>Node : 返回渲染结果
```

**图源**
- [SSRDriver.ts](file://packages/runtime-ssr/src/server/SSRDriver.ts)
- [HydrateDriver.ts](file://packages/runtime-ssr/src/client/HydrateDriver.ts)

**节源**
- [factory.ts](file://packages/runtime-ssr/src/factory.ts)
- [SSRDriver.ts](file://packages/runtime-ssr/src/server/SSRDriver.ts)

## SVG专用渲染器构建

构建SVG专用渲染器需要处理命名空间、属性映射和样式集成等关键问题。

### 命名空间处理

SVG渲染器必须正确处理XML命名空间，包括SVG主命名空间和XLink扩展命名空间：

```mermaid
classDiagram
class SVGNamespace {
+SVG_NAMESPACE : 'http : //www.w3.org/2000/svg'
+XLINK_NAMESPACE : 'http : //www.w3.org/1999/xlink'
+XMLNS_NAMESPACE : 'http : //www.w3.org/2000/xmlns/'
}
class ElementCreator {
+createElement()
+createElementNS()
}
class AttributeHandler {
+setXLinkAttribute()
+setXmlnsAttribute()
}
SVGNamespace --> ElementCreator : "使用"
SVGNamespace --> AttributeHandler : "使用"
ElementCreator --> DomRenderer : "集成"
AttributeHandler --> DomRenderer : "集成"
```

**图源**
- [DomRenderer.ts](file://packages/runtime-dom/src/DomRenderer.ts#L40-L41)

### 属性映射

SVG属性需要特殊映射处理，特别是XLink相关的属性：

```mermaid
flowchart TD
Start([设置SVG属性]) --> CheckPrefix{"检查属性前缀"}
CheckPrefix --> |以'xlink:'开头| SetXLink["使用setAttributeNS\n(XLINK_NAMESPACE)"]
CheckPrefix --> |'xmlns:xlink'| SetXmlns["使用setAttributeNS\n(XMLNS_NAMESPACE)"]
CheckPrefix --> |其他属性| SetNormal["使用setAttribute"]
SetXLink --> End
SetXmlns --> End
SetNormal --> End
```

**图源**
- [DomRenderer.ts](file://packages/runtime-dom/src/DomRenderer.ts#L275-L278)
- [DomRenderer.ts](file://packages/runtime-dom/src/DomRenderer.ts#L295-L297)

### 样式集成

SVG样式处理需要集成CSS样式工具，支持对象和字符串格式的样式：

```mermaid
classDiagram
class StyleUtils {
+cssStyleValueToString()
+cssStyleValueToObject()
+mergeCssStyle()
}
class DomRenderer {
+setStyle()
+addStyle()
+removeStyle()
}
StyleUtils --> DomRenderer : "使用"
StyleUtils : 转换样式对象与字符串
StyleUtils : 驼峰与kebab-case转换
DomRenderer : 调用StyleUtils处理样式
```

**图源**
- [style.ts](file://packages/runtime-core/src/utils/style.ts)
- [DomRenderer.ts](file://packages/runtime-dom/src/DomRenderer.ts#L239-L246)

**节源**
- [DomRenderer.ts](file://packages/runtime-dom/src/DomRenderer.ts)
- [style.ts](file://packages/runtime-core/src/utils/style.ts)

## 跨平台适配模式总结

### 通用模式

跨平台适配的通用模式包括接口抽象、条件编译和代理模式：

```mermaid
graph TD
A[统一接口] --> B[HostRenderer接口]
C[条件编译] --> D[__IS_SERVER__检测]
E[代理模式] --> F[空渲染器Proxy]
G[驱动器模式] --> H[SSRDriver]
I[命名空间处理] --> J[SVG命名空间]
B --> K[浏览器: DomRenderer]
B --> L[服务端: 空渲染器]
D --> M[服务端: SSR模式]
D --> N[客户端: DOM模式]
F --> O[拦截所有调用]
F --> P[抛出不支持错误]
H --> Q[只处理虚拟节点]
H --> R[不操作DOM]
J --> S[createElementNS]
J --> T[setAttributeNS]
```

### 反模式

跨平台适配应避免的反模式包括：

1. **直接DOM操作**：在服务端直接使用document.createElement等DOM API
2. **环境检测遗漏**：未检测运行环境就执行平台特定代码
3. **接口不一致**：不同平台的渲染器接口不统一
4. **硬编码路径**：直接引用平台特定的文件路径
5. **同步阻塞**：在服务端使用同步阻塞的DOM操作

正确的做法是通过统一接口、条件编译和代理模式来实现跨平台兼容。

**节源**
- [factory.ts](file://packages/runtime-ssr/src/factory.ts)
- [DomRenderer.ts](file://packages/runtime-dom/src/DomRenderer.ts)
- [SSRDriver.ts](file://packages/runtime-ssr/src/server/SSRDriver.ts)