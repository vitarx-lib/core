# 自定义指令

<cite>
**本文档引用文件**  
- [core.ts](file://packages/runtime-core/src/directive/core.ts)
- [directive.ts](file://packages/runtime-core/src/types/directive.ts)
- [show.ts](file://packages/runtime-core/src/directive/show.ts)
- [index.ts](file://packages/runtime-core/src/directive/index.ts)
- [BaseNode.ts](file://packages/runtime-core/src/types/nodes/BaseNode.ts)
- [scheduler.ts](file://packages/responsive/src/observer/scheduler.ts)
- [core.test.ts](file://packages/runtime-core/__tests__/directive/core.test.ts)
</cite>

## 目录
1. [简介](#简介)
2. [注册机制与指令规范化](#注册机制与指令规范化)
3. [作用域优先级与解析流程](#作用域优先级与解析流程)
4. [生命周期管理与差异更新](#生命周期管理与差异更新)
5. [指令应用与参数传递](#指令应用与参数传递)
6. [响应式更新机制](#响应式更新机制)
7. [完整示例：focus 与 debounce 指令](#完整示例focus-与-debounce-指令)
8. [总结](#总结)

## 简介
Vitarx 框架提供了一套灵活且强大的自定义指令系统，允许开发者通过声明式语法扩展 DOM 元素的行为。本文档深入解析其核心机制，涵盖指令的注册、存储、解析、生命周期管理以及与组件状态的交互方式。通过分析 `core.ts` 源码，我们将揭示 `defineDirective`、`withDirectives`、`resolveDirective` 和 `diffDirectives` 等关键函数的内部工作原理。

## 注册机制与指令规范化

`defineDirective` 函数是自定义指令系统的入口，负责将用户定义的指令规范化并存储到适当的缓存中。该函数接受指令名称和指令定义（可以是函数或对象），并根据当前上下文决定存储位置。

当在有状态组件的上下文中调用 `defineDirective` 时，指令会被存储在该组件虚拟节点（VNode）的 `directiveStore` 中，形成组件局部指令。否则，指令将被注册到全局指令缓存 `globalDirectives` 中，供全局使用。

指令规范化由 `normalizeDirective` 函数完成。如果传入的是一个函数，它会被包装成一个包含 `mounted` 和 `updated` 钩子的标准指令对象。如果传入的是一个对象，则会将其与指令名称合并，确保最终的指令对象符合 `Directive` 接口。

**Section sources**
- [core.ts](file://packages/runtime-core/src/directive/core.ts#L28-L87)

## 作用域优先级与解析流程

指令的解析遵循严格的优先级顺序：**组件局部指令 > 应用级指令 > 全局指令**。`resolveDirective` 函数负责根据指令名称查找并返回对应的指令对象。

解析流程如下：
1.  首先检查当前虚拟节点是否为有状态组件节点。
2.  如果是，则优先在该组件的 `directiveStore` 中查找。
3.  如果未找到，则尝试通过 `appContext.directive(name)` 查找应用级指令。
4.  最后，在全局指令缓存 `globalDirectives` 中查找。
5.  如果所有层级均未找到，则返回 `undefined` 并在开发模式下发出警告。

这种分层查找机制确保了指令的灵活性和可覆盖性，允许在不同作用域内定义同名但行为不同的指令。

```mermaid
flowchart TD
A[调用 resolveDirective(name)] --> B{当前VNode是<br/>有状态组件?}
B --> |是| C[查找组件局部指令<br/>vnode.directiveStore]
B --> |否| F[查找全局指令<br/>globalDirectives]
C --> D{找到?}
D --> |是| E[返回局部指令]
D --> |否| G[查找应用级指令<br/>vnode.appContext.directive]
G --> H{找到?}
H --> |是| I[返回应用级指令]
H --> |否| F
F --> J{找到?}
J --> |是| K[返回全局指令]
J --> |否| L[返回 undefined<br/>并发出警告]
```

**Diagram sources**
- [core.ts](file://packages/runtime-core/src/directive/core.ts#L174-L191)

**Section sources**
- [core.ts](file://packages/runtime-core/src/directive/core.ts#L174-L191)

## 生命周期管理与差异更新

指令的生命周期管理是通过 `diffDirectives` 函数在虚拟 DOM 的更新阶段实现的。该函数比较新旧虚拟节点的指令集合，并精确调用相应的生命周期钩子。

`diffDirectives` 的工作流程分为两个阶段：
1.  **新增与更新阶段**：遍历新节点的所有指令。
    *   如果该指令在旧节点中存在，则调用 `beforeUpdate` 和 `updated` 钩子（`updated` 被推入 `postFlush` 队列）。
    *   如果该指令在旧节点中不存在，则视为新增，调用 `beforeMount` 和 `mounted` 钩子。
2.  **删除阶段**：遍历旧节点的所有指令。
    *   如果该指令在新节点中不存在，则视为被移除，调用 `beforeUnmount` 和 `unmounted` 钩子。

`diffDirectives` 还支持 `DiffDirectivesOptions` 选项，允许通过 `only` 或 `skip` 参数精确控制哪些指令需要被处理，从而优化性能。

```mermaid
flowchart TD
A[调用 diffDirectives] --> B[获取新旧节点的<br/>指令集合]
B --> C[遍历新指令]
C --> D{旧节点中存在?}
D --> |是| E[调用 beforeUpdate<br/>更新指令状态]
D --> |否| F[调用 beforeMount<br/>mounted]
E --> G[调用 updated<br/>(postFlush)]
F --> G
G --> H[遍历旧指令]
H --> I{新节点中存在?}
I --> |否| J[调用 beforeUnmount<br/>unmounted]
I --> |是| K[跳过]
J --> L[结束]
K --> L
```

**Diagram sources**
- [core.ts](file://packages/runtime-core/src/directive/core.ts#L239-L301)

**Section sources**
- [core.ts](file://packages/runtime-core/src/directive/core.ts#L239-L301)

## 指令应用与参数传递

`withDirectives` 函数用于将指令应用到虚拟节点上。它支持两种指令传递格式：
1.  **元组数组形式**：`[directive, value?, arg?]`，其中 `value` 是传递给指令的值，`arg` 是指令参数。
2.  **简单对象数组形式**：`Directive[]`，仅包含指令对象。

当使用元组数组时，`withDirectives` 会解析出指令、值和参数，并将其存储在虚拟节点的 `directives` Map 中，以指令名称为键。`directives` 的类型定义为 `Map<string, [Directive, any, string | undefined]>`，清晰地表明了其存储结构。

```mermaid
erDiagram
VNODE ||--o{ DIRECTIVES : 包含
class VNode {
directives: Map<string, DirectiveEntry>
}
class DirectiveEntry {
[Directive, value: any, arg: string | undefined]
}
```

**Diagram sources**
- [BaseNode.ts](file://packages/runtime-core/src/types/nodes/BaseNode.ts#L20-L23)
- [core.ts](file://packages/runtime-core/src/directive/core.ts#L122-L154)

**Section sources**
- [core.ts](file://packages/runtime-core/src/directive/core.ts#L122-L154)
- [BaseNode.ts](file://packages/runtime-core/src/types/nodes/BaseNode.ts#L20-L23)

## 响应式更新机制

当指令与组件状态交互时，其响应式更新机制依赖于 Vitarx 的响应式系统。当指令绑定的值发生变化时，会触发组件的重新渲染。在更新阶段，`diffDirectives` 会被调用，比较新旧指令的值。

如果值发生变化，`diffDirectives` 会识别出这是一个更新操作，并调用 `beforeUpdate` 和 `updated` 钩子。在这些钩子函数中，开发者可以访问到新的值（`binding.value`）和旧的值（`binding.oldValue`），从而执行相应的 DOM 操作。`updated` 钩子被安排在 `postFlush` 队列中执行，确保其在所有 DOM 更新完成后调用，这有助于处理一些需要在 DOM 稳定后进行的操作。

**Section sources**
- [core.ts](file://packages/runtime-core/src/directive/core.ts#L271-L274)
- [scheduler.ts](file://packages/responsive/src/observer/scheduler.ts#L120-L126)

## 完整示例：focus 与 debounce 指令

以下示例展示了如何创建和使用 `focus` 和 `debounce` 指令。

**focus 指令**：一个简单的函数式指令，用于在元素挂载后自动获取焦点。
```typescript
const focusDirective = {
  name: 'focus',
  mounted: (el) => el.focus()
};
```

**debounce 指令**：一个对象式指令，用于为事件处理器添加防抖功能。`arg` 参数指定事件名称，`value` 参数指定防抖延迟时间。
```typescript
const debounceDirective = {
  name: 'debounce',
  mounted: (el, binding) => {
    const { arg: event, value: delay } = binding;
    let timer: number | null = null;
    const handler = () => {
      if (timer) clearTimeout(timer);
      timer = setTimeout(() => {
        // 触发事件
      }, delay);
    };
    el.addEventListener(event, handler);
    // 存储清理函数
    el._debounceHandler = handler;
  },
  unmounted: (el, binding) => {
    const { arg: event } = binding;
    const handler = el._debounceHandler;
    if (handler) {
      el.removeEventListener(event, handler);
      delete el._debounceHandler;
    }
  }
};
```

使用方式：
```jsx
<input v-focus />
<button v-debounce:click="500">防抖按钮</button>
```

**Section sources**
- [core.test.ts](file://packages/runtime-core/__tests__/directive/core.test.ts#L52-L74)
- [show.ts](file://packages/runtime-core/src/directive/show.ts#L4-L34)

## 总结
Vitarx 的自定义指令系统通过 `defineDirective`、`withDirectives`、`resolveDirective` 和 `diffDirectives` 四个核心函数，构建了一个完整且高效的指令管理闭环。它支持函数式和对象式两种定义方式，通过分层作用域提供灵活的指令覆盖机制，并利用精确的生命周期钩子和差异更新算法，确保了指令行为的可预测性和高性能。开发者可以利用这套系统轻松创建出如 `focus`、`debounce` 等实用的指令，极大地提升开发效率和代码的可维护性。