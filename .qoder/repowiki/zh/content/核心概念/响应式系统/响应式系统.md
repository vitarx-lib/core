# 响应式系统

<cite>
**本文档引用的文件**   
- [ref.ts](file://packages/responsive/src/signal/ref/ref.ts)
- [proxy-handler.ts](file://packages/responsive/src/signal/reactive/proxy-handler.ts)
- [computed.ts](file://packages/responsive/src/signal/computed/computed.ts)
- [watch.ts](file://packages/responsive/src/signal/watch/watch.ts)
- [manager.ts](file://packages/responsive/src/signal/manager.ts)
- [depend.ts](file://packages/responsive/src/depend/depend.ts)
- [subManager.ts](file://packages/responsive/src/observer/subManager.ts)
- [subscriber.ts](file://packages/responsive/src/observer/subscriber.ts)
- [constants.ts](file://packages/responsive/src/signal/constants.ts)
</cite>

## 目录
1. [引言](#引言)
2. [核心响应式API](#核心响应式api)
3. [响应式对象创建机制](#响应式对象创建机制)
4. [依赖追踪模型](#依赖追踪模型)
5. [副作用与调度机制](#副作用与调度机制)
6. [计算属性实现](#计算属性实现)
7. [数据监听系统](#数据监听系统)
8. [解构响应性保持](#解构响应性保持)
9. [只读响应式实现](#只读响应式实现)
10. [常见误区与解决方案](#常见误区与解决方案)

## 引言

Vitarx 的响应式系统基于 Proxy 代理和依赖追踪机制，提供了一套完整的响应式编程解决方案。系统通过 `ref`、`reactive`、`computed` 和 `watch` 等核心API，实现了数据的自动追踪和更新。响应式系统采用信号（Signal）架构，通过 `SIGNAL_SYMBOL` 等符号标识响应式对象，确保类型安全和运行时识别。

**Section sources**
- [constants.ts](file://packages/responsive/src/signal/constants.ts#L4-L25)

## 核心响应式API

### ref 响应式引用

`ref` 是响应式系统的基础单元，用于包装基本类型或对象，使其成为响应式数据。`ref` 通过 `value` 属性访问和修改值，当值发生变化时会触发依赖更新。

```mermaid
classDiagram
class Ref {
+[SIGNAL_SYMBOL] : true
+[REF_SIGNAL_SYMBOL] : true
+value : T
+[SIGNAL_RAW_VALUE_SYMBOL] : T
+[DEEP_SIGNAL_SYMBOL] : boolean
+[Symbol.toPrimitive](hint : string) : any
+toString() : string
+forceUpdate() : void
+set(value : T) : void
+update(value : T) : void
}
Ref --> Depend : "依赖追踪"
Ref --> SignalManager : "父级关系管理"
```

**Diagram sources**
- [ref.ts](file://packages/responsive/src/signal/ref/ref.ts#L70-L287)
- [depend.ts](file://packages/responsive/src/depend/depend.ts#L59-L64)
- [manager.ts](file://packages/responsive/src/signal/manager.ts#L39-L69)

### reactive 响应式对象

`reactive` 用于创建响应式对象，通过 Proxy 代理实现属性的拦截和追踪。所有对象属性都会被自动转换为响应式，支持深度代理。

```mermaid
classDiagram
class ReactiveProxyHandler {
+target : AnyObject
+options : Required<SignalOptions>
+childSignalMap? : Map<AnyKey, BaseSignal>
+isArray : boolean
+_proxy : Reactive<T, Deep> | null
+proxy : Reactive<T, Deep>
+get(target, prop, receiver) : any
+set(target, prop, newValue, receiver) : boolean
+deleteProperty(target, prop) : boolean
+has(target, prop) : boolean
+notify(prop : AnyKey) : void
+track(prop : AnyKey) : void
+removeChildSignal(prop : AnyKey) : void
}
ReactiveProxyHandler --> Depend : "依赖收集"
ReactiveProxyHandler --> SignalManager : "父子关系绑定"
ReactiveProxyHandler --> SubManager : "订阅管理"
```

**Diagram sources**
- [proxy-handler.ts](file://packages/responsive/src/signal/reactive/proxy-handler.ts#L83-L300)
- [depend.ts](file://packages/responsive/src/depend/depend.ts#L59-L64)
- [manager.ts](file://packages/responsive/src/signal/manager.ts#L39-L69)
- [subManager.ts](file://packages/responsive/src/observer/subManager.ts#L77-L91)

## 响应式对象创建机制

### ref 创建流程

`ref` 的创建过程包括值验证、选项配置和代理评估。当包装对象且启用深度代理时，会创建响应式代理对象。

```mermaid
flowchart TD
Start([创建 Ref]) --> ValidateInput["验证输入值"]
ValidateInput --> InputValid{"是否为 Ref?"}
InputValid --> |是| ReturnExist["返回现有 Ref"]
InputValid --> |否| ConfigOptions["配置选项"]
ConfigOptions --> EvaluateProxy["评估是否需要代理"]
EvaluateProxy --> IsObject{"是否为对象?"}
IsObject --> |否| StoreRaw["存储原始值"]
IsObject --> |是| CreateProxy["创建响应式代理"]
CreateProxy --> BindParent["绑定父级关系"]
BindParent --> ReturnRef["返回 Ref 实例"]
StoreRaw --> ReturnRef
```

**Diagram sources**
- [ref.ts](file://packages/responsive/src/signal/ref/ref.ts#L109-L181)
- [proxy-handler.ts](file://packages/responsive/src/signal/reactive/proxy-handler.ts#L378-L397)

### reactive 创建流程

`reactive` 通过 `ReactiveProxyHandler` 创建代理对象，实现属性的拦截和追踪。系统会根据对象类型选择不同的代理策略。

```mermaid
flowchart TD
Start([创建 Reactive]) --> ValidateTarget["验证目标对象"]
ValidateTarget --> IsObject{"是否为对象?"}
IsObject --> |否| ThrowError["抛出类型错误"]
IsObject --> |是| IsFrozen{"是否冻结?"}
IsFrozen --> |是| ThrowError
IsFrozen --> |否| IsRef{"是否为 Ref?"}
IsRef --> |是| ThrowError
IsRef --> |否| IsProxy{"是否已代理?"}
IsProxy --> |是| ReturnExist["返回现有代理"]
IsProxy --> |否| GetObjectType["获取对象类型"]
GetObjectType --> IsSet{"是否为 Set?"}
IsSet --> |是| CreateSetProxy["创建 Set 代理"]
IsSet --> |否| IsMap{"是否为 Map?"}
IsMap --> |是| CreateMapProxy["创建 Map 代理"]
IsMap --> |否| CreateObjectProxy["创建对象代理"]
CreateSetProxy --> ReturnProxy
CreateMapProxy --> ReturnProxy
CreateObjectProxy --> ReturnProxy
```

**Diagram sources**
- [proxy-handler.ts](file://packages/responsive/src/signal/reactive/proxy-handler.ts#L378-L397)
- [ref.ts](file://packages/responsive/src/signal/ref/ref.ts#L110-L114)

## 依赖追踪模型

### 依赖收集流程

依赖追踪系统通过 `Depend` 类实现，当访问响应式属性时会自动收集依赖关系。

```mermaid
sequenceDiagram
participant Code as "用户代码"
participant Ref as "Ref"
participant Depend as "Depend"
participant SubManager as "SubManager"
Code->>Ref : 访问 value
Ref->>Depend : track(this, 'value')
Depend->>Depend : 检查上下文
Depend->>Depend : 记录依赖
Ref-->>Code : 返回值
Code->>Ref : 修改 value
Ref->>SignalManager : notifySubscribers(this, 'value')
SignalManager->>SubManager : notify(this, 'value')
SubManager->>SubManager : 触发订阅者
```

**Diagram sources**
- [ref.ts](file://packages/responsive/src/signal/ref/ref.ts#L136-L146)
- [depend.ts](file://packages/responsive/src/depend/depend.ts#L59-L64)
- [manager.ts](file://packages/responsive/src/signal/manager.ts#L115-L122)
- [subManager.ts](file://packages/responsive/src/observer/subManager.ts#L77-L91)

### 依赖关系图

```mermaid
graph TD
A[Ref] --> B[Depend]
C[Reactive] --> B
D[Computed] --> B
B --> E[SubManager]
E --> F[Subscriber]
F --> G[Effect]
G --> H[EffectScope]
```

**Diagram sources**
- [ref.ts](file://packages/responsive/src/signal/ref/ref.ts)
- [proxy-handler.ts](file://packages/responsive/src/signal/reactive/proxy-handler.ts)
- [computed.ts](file://packages/responsive/src/signal/computed/computed.ts)
- [depend.ts](file://packages/responsive/src/depend/depend.ts)
- [subManager.ts](file://packages/responsive/src/observer/subManager.ts)
- [subscriber.ts](file://packages/responsive/src/observer/subscriber.ts)

## 副作用与调度机制

### Effect 与 Scheduler

副作用系统通过 `Effect` 和 `Scheduler` 实现，支持不同的调度模式。

```mermaid
classDiagram
class Subscriber {
+flush : Flush
+limit : number
+count : number
+_callback : CB
+_paramsHandler : QueueParamHandler
+trigger(...params) : void
+setFlush(flush) : this
+resetCount() : boolean
+_runCallback(...params) : void
}
class Scheduler {
+queueJob(job, params, handler) : void
+queuePreFlushJob(job, params, handler) : void
+queuePostFlushJob(job, params, handler) : void
}
Subscriber --> Scheduler : "调度执行"
Subscriber --> EffectScope : "作用域管理"
```

**Diagram sources**
- [subscriber.ts](file://packages/responsive/src/observer/subscriber.ts#L98-L247)
- [scheduler.ts](file://packages/responsive/src/observer/scheduler.ts)
- [effect-scope.ts](file://packages/responsive/src/effect/effect-scope.ts)

### 调度流程

```mermaid
flowchart TD
Start([触发更新]) --> CheckFlush["检查 flush 模式"]
CheckFlush --> IsSync{"是否同步?"}
IsSync --> |是| ExecuteNow["立即执行回调"]
IsSync --> |否| IsPre{"是否 pre?"}
IsPre --> |是| QueuePre["加入 pre 队列"]
IsPre --> |否| IsPost{"是否 post?"}
IsPost --> |是| QueuePost["加入 post 队列"]
IsPost --> |否| QueueDefault["加入默认队列"]
QueuePre --> ExecutePre["在更新前执行"]
QueuePost --> ExecutePost["在更新后执行"]
QueueDefault --> ExecuteDefault["在更新时执行"]
```

**Diagram sources**
- [subscriber.ts](file://packages/responsive/src/observer/subscriber.ts#L180-L194)
- [scheduler.ts](file://packages/responsive/src/observer/scheduler.ts)

## 计算属性实现

### Computed 类结构

`computed` 实现了懒计算和缓存机制，只有在依赖变化时才会重新计算。

```mermaid
classDiagram
class Computed {
+[DEEP_SIGNAL_SYMBOL] : boolean
+[REF_SIGNAL_SYMBOL] : true
+[SIGNAL_SYMBOL] : true
+_dirty : boolean
+_getter : ComputedGetter<T>
+_setter? : ComputedSetter<T>
+_effect : Subscriber | undefined
+_scope : EffectScope | undefined
+_isSetup : boolean
+_value : T
+value : T
+[SIGNAL_RAW_VALUE_SYMBOL] : T
+toString() : string
+[Symbol.toPrimitive](hint : string) : any
+stop() : T
+_evaluate() : void
+_setupEffect() : void
}
Computed --> Depend : "依赖收集"
Computed --> SubManager : "订阅管理"
Computed --> EffectScope : "作用域管理"
```

**Diagram sources**
- [computed.ts](file://packages/responsive/src/signal/computed/computed.ts#L98-L366)
- [depend.ts](file://packages/responsive/src/depend/depend.ts#L75-L79)
- [subManager.ts](file://packages/responsive/src/observer/subManager.ts#L123-L131)

### 计算属性流程

```mermaid
flowchart TD
Start([访问 computed.value]) --> IsSetup{"是否已设置?"}
IsSetup --> |否| SetupEffect["设置副作用"]
SetupEffect --> CollectDeps["收集依赖"]
CollectDeps --> CacheResult["缓存结果"]
CacheResult --> MarkClean["标记为干净"]
SetupEffect --> MarkClean
IsSetup --> |是| IsDirty{"是否脏?"}
IsDirty --> |否| TrackAccess["追踪访问"]
IsDirty --> |是| Evaluate["重新计算"]
Evaluate --> UpdateCache["更新缓存"]
UpdateCache --> MarkClean
MarkClean --> TrackAccess
TrackAccess --> ReturnResult["返回结果"]
```

**Diagram sources**
- [computed.ts](file://packages/responsive/src/signal/computed/computed.ts#L202-L217)
- [depend.ts](file://packages/responsive/src/depend/depend.ts#L75-L79)

## 数据监听系统

### watch 实现机制

`watch` 系统支持监听信号、函数和数组，提供灵活的数据变化响应。

```mermaid
classDiagram
class Watch {
+source : T
+callback : C
+options : WatchOptions
+target : T
+cleanupFn : AnyFunction
+cacheValue : any
+onCleanup(handler) : void
+clean() : void
}
Watch --> Depend : "依赖订阅"
Watch --> SubManager : "属性订阅"
Watch --> SignalManager : "父级绑定"
```

**Diagram sources**
- [watch.ts](file://packages/responsive/src/signal/watch/watch.ts#L192-L295)
- [depend.ts](file://packages/responsive/src/depend/depend.ts#L129-L151)
- [subManager.ts](file://packages/responsive/src/observer/subManager.ts#L149-L157)

### 监听类型处理

```mermaid
flowchart TD
Start([watch 调用]) --> CheckSource["检查源类型"]
CheckSource --> IsFunction{"是否为函数?"}
IsFunction --> |是| SubscribeEffect["订阅副作用"]
IsFunction --> |否| IsSignal{"是否为信号?"}
IsSignal --> |是| HandleSignal["处理信号"]
IsSignal --> |否| IsArray{"是否为数组?"}
IsArray --> |是| HandleArray["处理数组"]
IsArray --> |否| ThrowError["抛出类型错误"]
SubscribeEffect --> ReturnSubscriber
HandleSignal --> ReturnSubscriber
HandleArray --> ReturnSubscriber
```

**Diagram sources**
- [watch.ts](file://packages/responsive/src/signal/watch/watch.ts#L192-L295)

## 解构响应性保持

### toRefs 实现

`toRefs` 将响应式对象的每个属性转换为 ref，保持解构后的响应性。

```mermaid
flowchart TD
Start([toRefs 调用]) --> IterateProps["遍历对象属性"]
IterateProps --> IsRef{"是否为 ref?"}
IsRef --> |是| KeepRef["保持原有 ref"]
IsRef --> |否| CreateRef["创建新 ref"]
CreateRef --> ProxyAccess["代理访问和修改"]
ProxyAccess --> StoreOriginal["存储原始值"]
ProxyAccess --> ReturnRef["返回 ref"]
KeepRef --> ReturnRef
IterateProps --> AllPropsDone{"所有属性处理完成?"}
AllPropsDone --> |否| IterateProps
AllPropsDone --> |是| ReturnResult["返回 refs 对象"]
```

**Section sources**
- [ref.ts](file://packages/responsive/src/signal/ref/ref.ts#L39-L41)
- [utils/conversion.ts](file://packages/responsive/src/signal/utils/conversion.ts)

## 只读响应式实现

### readonly 机制

`readonly` 创建只读的响应式代理，禁止属性修改。

```mermaid
classDiagram
class ReadonlyProxyHandler {
+get(target, prop, receiver) : any
+set() : boolean
+deleteProperty() : boolean
+has(target, prop) : boolean
}
ReadonlyProxyHandler --> Depend : "依赖追踪"
ReadonlyProxyHandler --> SubManager : "变更通知"
```

**Section sources**
- [readonly/readonly.ts](file://packages/responsive/src/signal/readonly/readonly.ts)
- [proxy-handler.ts](file://packages/responsive/src/signal/reactive/proxy-handler.ts)

## 常见误区与解决方案

### 响应性丢失场景

```mermaid
flowchart TD
A[响应性丢失] --> B[直接替换对象]
A --> C[解构赋值]
A --> D[数组索引赋值]
A --> E[浅层代理]
B --> B1["解决方案: 使用 Object.assign 或展开运算符"]
C --> C1["解决方案: 使用 toRefs"]
D --> D1["解决方案: 使用 splice 或 length 修改"]
E --> E1["解决方案: 使用 forceUpdate 或重新赋值"]
```

**Section sources**
- [ref.ts](file://packages/responsive/src/signal/ref/ref.ts#L171-L182)
- [proxy-handler.ts](file://packages/responsive/src/signal/reactive/proxy-handler.ts#L251-L263)
- [manager.ts](file://packages/responsive/src/signal/manager.ts#L144-L152)

### 信号架构差异

```mermaid
classDiagram
class RefSignal {
+value : T
+[REF_SIGNAL_SYMBOL] : true
}
class ProxySignal {
+[PROXY_SIGNAL_SYMBOL] : true
+[DEEP_SIGNAL_SYMBOL] : boolean
}
RefSignal --> BaseSignal
ProxySignal --> BaseSignal
BaseSignal --> AnyObject
class BaseSignal {
+[SIGNAL_SYMBOL] : true
+[SIGNAL_RAW_VALUE_SYMBOL] : T
}
```

**Diagram sources**
- [types/base.ts](file://packages/responsive/src/signal/types/base.ts)
- [types/ref.ts](file://packages/responsive/src/signal/types/ref.ts)
- [types/proxy.ts](file://packages/responsive/src/signal/types/proxy.ts)
- [constants.ts](file://packages/responsive/src/signal/constants.ts#L4-L25)