# 类组件

<cite>
**本文档引用的文件**
- [Widget.ts](file://packages/runtime-core/src/widget/base/Widget.ts)
- [Stateful.ts](file://packages/runtime-core/src/widget/runtime/Stateful.ts)
- [effect-scope.ts](file://packages/responsive/src/effect/effect-scope.ts)
- [scheduler.ts](file://packages/responsive/src/observer/scheduler.ts)
- [effect.ts](file://packages/responsive/src/effect/effect.ts)
- [helpers.ts](file://packages/responsive/src/effect/helpers.ts)
- [lifecycle.ts](file://packages/runtime-core/src/types/lifecycle.ts)
- [hook.ts](file://packages/runtime-core/src/constants/hook.ts)
- [nodeState.ts](file://packages/runtime-core/src/constants/nodeState.ts)
- [widget.ts](file://packages/runtime-core/src/vnode/creator/widget.ts)
- [depend.ts](file://packages/responsive/src/depend/depend.ts)
- [depend/helpers.ts](file://packages/responsive/src/depend/helpers.ts)
</cite>

## 目录
1. [引言](#引言)
2. [核心架构](#核心架构)
3. [类组件生命周期](#类组件生命周期)
4. [依赖追踪与自动更新](#依赖追踪与自动更新)
5. [更新调度机制](#更新调度机制)
6. [错误处理机制](#错误处理机制)
7. [使用示例](#使用示例)

## 引言
Vitarx 的类组件（StatefulWidget）架构设计基于响应式编程范式，通过 `Widget` 基类和 `StatefulWidgetRuntime` 运行时管理器的协作，实现了高效的视图更新和生命周期管理。本文档将深入解析这一架构的核心机制。

## 核心架构
Vitarx 的类组件架构由 `Widget` 基类和 `StatefulWidgetRuntime` 运行时管理器构成，二者通过虚拟节点（VNode）进行关联和协作。

```mermaid
classDiagram
class Widget {
+static CLASS_WIDGET_BASE_SYMBOL
+readonly NON_SIGNAL_SYMBOL
+props : ReadonlyProps
+children : ExtractChildrenType
+$el : NodeElementType
+$vnode : StatefulWidgetVNode
+onCreate() : void
+onBeforeMount() : void
+onMounted() : void
+onActivated() : void
+onDeactivated() : void
+onBeforeUpdate() : void
+onUpdated() : void
+onBeforeUnmount() : void
+onUnmounted() : void
+onError(error : unknown, info : ErrorInfo) : any
+onRender() : Promise~unknown~ | void
+onDestroy() : void
+abstract build() : Renderable
+$patchUpdate?(currentVNode : VNode, nextVNode : VNode) : VNode
+$forceUpdate(sync : boolean) : void
}
class StatefulWidgetRuntime {
+scope : EffectScope
+deps : DependencyMap | null
+dirty : boolean
+options : StatefulManagerOptions
+instance : WidgetInstanceType
+hasPendingUpdate : boolean
+renderDepsSubscriber : Subscriber | null
+reportError(error : unknown, source : ErrorSource, instance? : Widget) : VNode | void
+invokeHook(hookName : LifecycleHooks, ...args) : LifecycleHookReturnType | void
+update() : void
+destroy() : void
+build() : VNode
+createWidgetInstance() : WidgetInstanceType
}
class WidgetRuntime {
+name : string
+props : Readonly~Record~string, any~~
+cachedChildVNode : VNode | null
+vnode : WidgetVNode
+child : VNode
+type : T
+state : NodeState
+destroy() : void
+abstract build() : VNode
+abstract update() : void
+runInContext(fn) : R
}
WidgetRuntime <|-- StatefulWidgetRuntime
WidgetRuntime <-- Widget : "通过$vnode关联"
StatefulWidgetRuntime --> EffectScope : "管理"
StatefulWidgetRuntime --> Subscriber : "依赖订阅"
StatefulWidgetRuntime --> Scheduler : "任务调度"
```

**图示来源**
- [Widget.ts](file://packages/runtime-core/src/widget/base/Widget.ts#L45-L387)
- [Stateful.ts](file://packages/runtime-core/src/widget/runtime/Stateful.ts#L69-L367)
- [WidgetRuntime.ts](file://packages/runtime-core/src/widget/runtime/WidgetRuntime.ts#L35-L122)

**本节来源**
- [Widget.ts](file://packages/runtime-core/src/widget/base/Widget.ts#L1-L387)
- [Stateful.ts](file://packages/runtime-core/src/widget/runtime/Stateful.ts#L1-L367)

## 类组件生命周期
类组件的生命周期由 `StatefulWidgetRuntime` 管理，通过 `invokeHook` 方法调用相应的生命周期钩子。生命周期的执行流程严格遵循组件的状态变化。

```mermaid
stateDiagram-v2
[*] --> Created
Created --> BeforeMount : "挂载前"
BeforeMount --> Mounted : "挂载完成"
Mounted --> BeforeUpdate : "更新前"
BeforeUpdate --> Updated : "更新完成"
Updated --> Mounted : "继续活跃"
Mounted --> BeforeUnmount : "卸载前"
BeforeUnmount --> Unmounted : "卸载完成"
Mounted --> Deactivated : "停用"
Deactivated --> Activated : "重新激活"
Activated --> BeforeUpdate : "更新前"
Deactivated --> Unmounted : "卸载完成"
BeforeUnmount --> Destroyed : "销毁"
Unmounted --> Destroyed : "销毁"
note right of Created
调用 onCreate
创建组件实例
end note
note right of BeforeMount
调用 onBeforeMount
此时尚未创建真实DOM
end note
note right of Mounted
调用 onMounted
可以访问真实DOM元素
end note
note right of BeforeUpdate
调用 onBeforeUpdate
记录更新前状态
end note
note right of Updated
调用 onUpdated
恢复布局或滚动位置
end note
note left of Deactivated
调用 onDeactivated
缓存组件状态
end note
note left of Activated
调用 onActivated
恢复连接或轮询
end note
note left of BeforeUnmount
调用 onBeforeUnmount
清理事件监听器
end note
note left of Unmounted
调用 onUnmounted
组件已从DOM移除
end note
note left of Destroyed
调用 onDestroy
释放所有资源
end note
```

**图示来源**
- [Stateful.ts](file://packages/runtime-core/src/widget/runtime/Stateful.ts#L172-L193)
- [hook.ts](file://packages/runtime-core/src/constants/hook.ts#L2-L15)
- [nodeState.ts](file://packages/runtime-core/src/constants/nodeState.ts#L12-L17)

**本节来源**
- [Widget.ts](file://packages/runtime-core/src/widget/base/Widget.ts#L120-L338)
- [Stateful.ts](file://packages/runtime-core/src/widget/runtime/Stateful.ts#L172-L193)
- [lifecycle.ts](file://packages/runtime-core/src/types/lifecycle.ts#L1-L138)

## 依赖追踪与自动更新
`StatefulWidgetRuntime` 利用 `EffectScope` 和 `depSubscribe` 实现了自动依赖追踪与视图更新。当组件依赖的响应式数据发生变化时，会自动触发视图更新。

```mermaid
sequenceDiagram
participant Component as "类组件"
participant Runtime as "StatefulWidgetRuntime"
participant EffectScope as "EffectScope"
participant Subscriber as "Subscriber"
participant Scheduler as "Scheduler"
Component->>Runtime : build()
Runtime->>EffectScope : scope.run()
EffectScope->>Runtime : 执行 buildChildVNode
Runtime->>Runtime : buildChildVNode()
Runtime->>Subscriber : depSubscribe(buildChildVNode, update)
Subscriber->>Runtime : 收集依赖 (deps)
Subscriber->>Runtime : 返回结果和订阅者
Runtime->>Runtime : renderDepsSubscriber = subscriber
Runtime->>EffectScope : addEffect(subscriber)
Subscriber->>Runtime : 当依赖变化时
Runtime->>Scheduler : queueJob(finishUpdate)
Scheduler->>Runtime : 执行 finishUpdate
Runtime->>Runtime : patch() 更新视图
```

**图示来源**
- [Stateful.ts](file://packages/runtime-core/src/widget/runtime/Stateful.ts#L256-L275)
- [helpers.ts](file://packages/responsive/src/depend/helpers.ts#L92-L97)
- [depend.ts](file://packages/responsive/src/depend/depend.ts#L129-L150)
- [scheduler.ts](file://packages/responsive/src/observer/scheduler.ts#L105-L111)

**本节来源**
- [Stateful.ts](file://packages/runtime-core/src/widget/runtime/Stateful.ts#L256-L275)
- [effect-scope.ts](file://packages/responsive/src/effect/effect-scope.ts#L123-L125)
- [helpers.ts](file://packages/responsive/src/depend/helpers.ts#L92-L97)

## 更新调度机制
`StatefulWidgetRuntime` 的 `update` 方法通过 `Scheduler.queueJob` 实现异步调度，避免了重复渲染，提高了性能。

```mermaid
flowchart TD
A["update() 被调用"] --> B{hasPendingUpdate?}
B --> |是| C["直接返回，避免重复调度"]
B --> |否| D["设置 hasPendingUpdate = true"]
D --> E["调用 onBeforeUpdate 钩子"]
E --> F{enableScheduler?}
F --> |是| G["Scheduler.queueJob(finishUpdate)"]
F --> |否| H["直接执行 finishUpdate()"]
G --> I["微任务队列等待执行"]
H --> J["立即执行 finishUpdate"]
I --> J
J --> K["执行 patch() 更新视图"]
K --> L["调用 onUpdated 钩子"]
L --> M["重置 hasPendingUpdate = false"]
```

**图示来源**
- [Stateful.ts](file://packages/runtime-core/src/widget/runtime/Stateful.ts#L203-L212)
- [scheduler.ts](file://packages/responsive/src/observer/scheduler.ts#L105-L111)
- [scheduler.ts](file://packages/responsive/src/observer/scheduler.ts#L243-L247)

**本节来源**
- [Stateful.ts](file://packages/runtime-core/src/widget/runtime/Stateful.ts#L203-L212)
- [scheduler.ts](file://packages/responsive/src/observer/scheduler.ts#L1-L325)

## 错误处理机制
Vitarx 的错误处理机制采用冒泡策略，通过 `invokeHook` 方法调用 `onError` 钩子，并在发生错误时向上冒泡到父组件。

```mermaid
sequenceDiagram
participant Component as "组件实例"
participant Runtime as "StatefulWidgetRuntime"
participant Parent as "父组件"
participant App as "应用级处理器"
Component->>Runtime : 抛出错误
Runtime->>Runtime : invokeHook(LifecycleHooks.error)
Runtime->>Component : 调用 onError(error, info)
Component-->>Runtime : 返回 false 或 VNode
alt 返回 false
Runtime-->>Component : 停止冒泡
else 返回 VNode
Runtime-->>Component : 使用备用UI渲染
else 无返回
Runtime->>Parent : 查找父组件
Parent->>Parent : reportError(error, source, instance)
Parent->>App : 调用应用级错误处理器
App-->>Parent : 返回备用UI或undefined
Parent-->>Runtime : 返回结果
Runtime-->>Component : 使用备用UI渲染或忽略
end
```

**图示来源**
- [Stateful.ts](file://packages/runtime-core/src/widget/runtime/Stateful.ts#L118-L155)
- [Stateful.ts](file://packages/runtime-core/src/widget/runtime/Stateful.ts#L172-L193)
- [lifecycle.ts](file://packages/runtime-core/src/types/lifecycle.ts#L18-L50)

**本节来源**
- [Stateful.ts](file://packages/runtime-core/src/widget/runtime/Stateful.ts#L118-L193)
- [lifecycle.ts](file://packages/runtime-core/src/types/lifecycle.ts#L1-L138)

## 使用示例
以下示例展示了如何创建类组件、管理内部状态、实现自定义更新逻辑以及处理组件销毁时的资源清理。

```mermaid
classDiagram
class CounterWidget {
-count : number
-timer : number
-websocket : WebSocket
+build() : Renderable
+onCreate() : void
+onMounted() : void
+onUpdated() : void
+onBeforeUnmount() : void
+onError(error : unknown, info : ErrorInfo) : any
}
CounterWidget --> Widget : "继承"
```

**图示来源**
- [Widget.ts](file://packages/runtime-core/src/widget/base/Widget.ts#L45-L387)

**本节来源**
- [Widget.ts](file://packages/runtime-core/src/widget/base/Widget.ts#L120-L338)
- [Stateful.ts](file://packages/runtime-core/src/widget/runtime/Stateful.ts#L203-L212)