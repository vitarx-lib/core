# 响应式系统

<cite>
**本文档引用文件**  
- [manager.ts](file://packages/responsive/src/signal/manager.ts)
- [depend.ts](file://packages/responsive/src/depend/depend.ts)
- [scheduler.ts](file://packages/responsive/src/observer/scheduler.ts)
- [ref.ts](file://packages/responsive/src/signal/ref/ref.ts)
- [computed.ts](file://packages/responsive/src/signal/computed/computed.ts)
- [effect.ts](file://packages/responsive/src/effect/effect.ts)
- [proxy-handler.ts](file://packages/responsive/src/signal/reactive/proxy-handler.ts)
</cite>

## 目录
1. [引言](#引言)
2. [核心API设计与实现](#核心api设计与实现)
3. [响应式对象创建机制](#响应式对象创建机制)
4. [RefSignal值包装机制](#refsignal值包装机制)
5. [计算属性实现原理](#计算属性实现原理)
6. [依赖收集与副作用触发](#依赖收集与副作用触发)
7. [更新调度策略](#更新调度策略)
8. [高级使用模式](#高级使用模式)
9. [信号管理器角色分析](#信号管理器角色分析)
10. [结论](#结论)

## 引言
vitarx响应式系统提供了一套完整的响应式编程解决方案，通过ref、reactive、computed和watch等核心API实现了数据驱动的编程范式。该系统基于Proxy实现深层/浅层响应式对象，采用依赖收集和副作用触发机制来实现自动更新。本文将深入解析该系统的设计与实现原理。

## 核心API设计与实现

### ref API
`ref` API用于创建响应式引用对象，将普通值包装为响应式信号。当引用的值发生变化时，所有依赖于该引用的计算和副作用将自动更新。

**中文(中文)**
- [ref.ts](file://packages/responsive/src/signal/ref/ref.ts#L355-L406)

### reactive API
`reactive` API用于创建深层响应式对象，通过Proxy代理对象的所有属性访问和修改操作，实现嵌套对象的完全响应式。

**中文(中文)**
- [proxy-handler.ts](file://packages/responsive/src/signal/reactive/proxy-handler.ts)

### computed API
`computed` API用于创建计算属性，实现懒求值和缓存机制。只有当依赖的响应式数据发生变化时，才会重新计算值。

**中文(中文)**
- [computed.ts](file://packages/responsive/src/signal/computed/computed.ts)

### watch API
`watch` API用于监听响应式数据的变化，当数据发生变化时执行指定的回调函数，支持同步、预和后置等调度策略。

**中文(中文)**
- [effect.ts](file://packages/responsive/src/effect/effect.ts)

## 响应式对象创建机制

### 深层响应式对象
深层响应式对象通过Proxy递归代理所有嵌套属性，确保任何层级的数据变化都能被正确追踪。系统使用`DEEP_SIGNAL_SYMBOL`标识深度代理配置。

```mermaid
classDiagram
class ReactiveObject {
+[SIGNAL_SYMBOL] : boolean
+[DEEP_SIGNAL_SYMBOL] : boolean
+[SIGNAL_RAW_VALUE_SYMBOL] : any
+get(target, property, receiver) : any
+set(target, property, value, receiver) : boolean
+deleteProperty(target, property) : boolean
}
class ProxyHandler {
+createReactiveHandler(deep : boolean) : ProxyHandler
+get(target, property, receiver) : any
+set(target, property, value, receiver) : boolean
}
ProxyHandler --> ReactiveObject : "创建"
```

**中文(中文)**
- [proxy-handler.ts](file://packages/responsive/src/signal/reactive/proxy-handler.ts)
- [ref.ts](file://packages/responsive/src/signal/ref/ref.ts#L241-L247)

### 浅层响应式对象
浅层响应式对象仅代理对象本身，不递归代理嵌套属性。这种模式适用于性能敏感的场景，避免不必要的代理开销。

```mermaid
flowchart TD
Start([创建浅层响应式对象]) --> CheckType["检查值类型"]
CheckType --> |对象类型| CreateShallowProxy["创建浅层Proxy"]
CheckType --> |非对象类型| ReturnOriginal["返回原始值"]
CreateShallowProxy --> SetDeepFalse["设置deep=false"]
SetDeepFalse --> ReturnProxy["返回Proxy实例"]
ReturnOriginal --> End([完成])
ReturnProxy --> End
```

**中文(中文)**
- [ref.ts](file://packages/responsive/src/signal/ref/ref.ts#L466-L472)

## RefSignal值包装机制

### Ref类结构
`Ref`类实现了`RefSignal`接口，通过`value`属性提供响应式访问。内部使用`_value`存储原始值，并根据配置决定是否需要代理。

```mermaid
classDiagram
class Ref {
+[SIGNAL_SYMBOL] : true
+[REF_SIGNAL_SYMBOL] : true
+_options : Required<SignalOptions>
+_shouldProxyValue : boolean
+_reactiveValue? : RefValue
+_value : T
+value : RefValue
+[SIGNAL_RAW_VALUE_SYMBOL] : T
+[DEEP_SIGNAL_SYMBOL] : Deep
+constructor(value : T, options? : SignalOptions)
+evaluateProxyNeeded() : void
+forceUpdate() : void
+set(value : T) : void
+update(value : T) : void
}
class RefSignal {
<<interface>>
+value : any
}
Ref --> RefSignal : "实现"
```

**中文(中文)**
- [ref.ts](file://packages/responsive/src/signal/ref/ref.ts#L70-L287)

### 值访问与更新流程
当访问`value`属性时，系统会根据当前状态决定返回原始值、已创建的响应式代理或创建新的响应式代理。更新值时会进行比较，只有当新旧值不同时才触发更新。

```mermaid
flowchart TD
GetValue["访问value属性"] --> HasReactiveValue{"存在_reactiveValue?"}
HasReactiveValue --> |是| ReturnReactive["返回_reactiveValue"]
HasReactiveValue --> |否| ShouldProxy{"需要代理?"}
ShouldProxy --> |是| CreateReactive["创建reactive代理"]
CreateReactive --> BindParent["绑定父级关系"]
BindParent --> ReturnReactive
ShouldProxy --> |否| TrackDepend["追踪依赖"]
TrackDepend --> ReturnOriginal["返回_value"]
SetValue["设置value属性"] --> IsRefValue{"值为Ref?"}
IsRefValue --> |是| ThrowError["抛出错误"]
IsRefValue --> |否| CompareValue["比较新旧值"]
CompareValue --> |相同| End([结束])
CompareValue --> |不同| ClearReactive["清理_reactiveValue"]
ClearReactive --> UpdateValue["更新_value"]
UpdateValue --> ReevaluateProxy["重新评估代理需求"]
ReevaluateProxy --> NotifySubscribers["通知订阅者"]
NotifySubscribers --> End
```

**中文(中文)**
- [ref.ts](file://packages/responsive/src/signal/ref/ref.ts#L136-L182)

## 计算属性实现原理

### 懒求值机制
计算属性采用懒求值策略，只有在被访问时才会执行计算函数。系统通过`Depend.collect`收集依赖，并在依赖变化时标记为脏状态。

```mermaid
classDiagram
class ComputedRef {
+_dirty : boolean
+_value : T
+_effect : Effect
+get value() : T
+set value(v : T) : void
+_run() : void
+_track() : void
+_trigger() : void
}
class Effect {
+run() : T
+stop() : void
+pause() : boolean
+resume() : boolean
}
ComputedRef --> Effect : "包含"
```

**中文(中文)**
- [computed.ts](file://packages/responsive/src/signal/computed/computed.ts)

### 缓存机制
计算属性通过`_dirty`标志位实现缓存，只有当依赖发生变化时才重新计算值，否则直接返回缓存的结果。

```mermaid
flowchart TD
GetComputedValue["访问计算属性值"] --> IsDirty{"_dirty为true?"}
IsDirty --> |是| RunEffect["执行_effect.run()"]
RunEffect --> UpdateValue["更新_value"]
UpdateValue --> MarkNotDirty["设置_dirty=false"]
MarkNotDirty --> ReturnCachedValue["返回_value"]
IsDirty --> |否| ReturnCachedValue
```

**中文(中文)**
- [computed.ts](file://packages/responsive/src/signal/computed/computed.ts)

## 依赖收集与副作用触发

### 依赖收集流程
依赖收集通过`Depend.track`和`Depend.collect`实现。当响应式数据被访问时，`track`方法记录依赖关系；当执行副作用函数时，`collect`方法收集所有依赖。

```mermaid
sequenceDiagram
participant Tracker as "追踪函数"
participant Depend as "Depend"
participant Context as "Context"
Tracker->>Depend : 执行tracker函数
Depend->>Context : 创建依赖收集上下文
loop 每个响应式访问
Tracker->>Depend : 访问响应式属性
Depend->>Depend : track(target, property)
Depend->>Context : 记录依赖
end
Depend-->>Tracker : 返回结果和依赖映射
```

**中文(中文)**
- [depend.ts](file://packages/responsive/src/depend/depend.ts#L59-L78)

### 副作用触发机制
副作用通过`Depend.subscribe`创建订阅者，当依赖的数据发生变化时，通知订阅者执行回调函数。

```mermaid
sequenceDiagram
participant Subscriber as "订阅者"
participant SubManager as "SubManager"
participant Scheduler as "Scheduler"
Subscriber->>SubManager : 订阅属性变化
SubManager->>SubManager : 存储订阅关系
Note over SubManager : 数据变化时
SubManager->>Scheduler : 调度更新任务
Scheduler->>Subscriber : 执行回调函数
```

**中文(中文)**
- [depend.ts](file://packages/responsive/src/depend/depend.ts#L129-L149)

## 更新调度策略

### 三阶段调度队列
调度器采用三阶段队列：preFlush（准备阶段）、main（执行阶段）和postFlush（清理阶段），确保任务按正确顺序执行。

```mermaid
classDiagram
class Scheduler {
+preFlushQueue : QueueMap
+mainQueue : QueueMap
+postFlushQueue : QueueMap
+isFlushing : boolean
+isFlushPending : boolean
+queuePreFlushJob(job, params, handleParams) : void
+queueJob(job, params, handleParams) : void
+queuePostFlushJob(job, params, handleParams) : void
+flushAll() : void
+flushJobMap(queue) : void
+runJob(job, params) : void
}
```

**中文(中文)**
- [scheduler.ts](file://packages/responsive/src/observer/scheduler.ts#L54-L61)

### 调度流程
调度器使用微任务机制，确保所有任务在下一个事件循环中执行，避免重复刷新。

```mermaid
flowchart TD
AddJob["添加任务到队列"] --> HasPending{"isFlushPending?"}
HasPending --> |否| SetPending["设置isFlushPending=true"]
SetPending --> ScheduleNextTick["调度nextTick"]
ScheduleNextTick --> ExecuteFlush["执行flushAll"]
HasPending --> |是| WaitFlush["等待现有刷新完成"]
ExecuteFlush --> SetFlushing["设置isFlushing=true"]
SetFlushing --> ExecutePre["执行preFlush队列"]
ExecutePre --> ExecuteMain["执行main队列"]
ExecuteMain --> ExecutePost["执行postFlush队列"]
ExecutePost --> ResetState["重置状态"]
ResetState --> End([完成])
```

**中文(中文)**
- [scheduler.ts](file://packages/responsive/src/observer/scheduler.ts#L243-L247)

## 高级使用模式

### toRefs解构
`toRefs`模式允许将响应式对象的属性解构为独立的ref，保持响应式连接。

```mermaid
flowchart TD
Start([toRefs处理]) --> InputObject["输入响应式对象"]
InputObject --> CreateRefs["为每个属性创建ref"]
CreateRefs --> LinkToOriginal["链接到原始对象属性"]
LinkToOriginal --> ReturnRefs["返回ref对象"]
ReturnRefs --> Usage["解构使用"]
Usage --> UpdateOriginal["更新原始对象"]
UpdateOriginal --> SyncRefs["同步所有ref"]
SyncRefs --> End([完成])
```

**中文(中文)**
- [ref.ts](file://packages/responsive/src/signal/ref/ref.ts)

### shallowRef性能优化
`shallowRef`用于创建浅层响应式引用，避免对大型对象或性能敏感数据进行深度代理，提高性能。

```mermaid
flowchart TD
CreateShallowRef["创建shallowRef"] --> SetDeepFalse["设置deep=false"]
SetDeepFalse --> StoreValue["存储原始值"]
StoreValue --> AccessValue["访问value属性"]
AccessValue --> ReturnOriginal["直接返回原始值"]
ReturnOriginal --> ModifyNested["修改嵌套属性"]
ModifyNested --> NoAutoUpdate["不会自动触发更新"]
NoAutoUpdate --> ManualUpdate["需要手动forceUpdate"]
ManualUpdate --> TriggerUpdate["触发更新"]
TriggerUpdate --> End([完成])
```

**中文(中文)**
- [ref.ts](file://packages/responsive/src/signal/ref/ref.ts#L466-L472)

## 信号管理器角色分析

### 父子关系管理
`SignalManager`负责管理信号之间的父子关系，通过`WeakMap`存储父子映射，支持递归通知。

```mermaid
classDiagram
class SignalManager {
+_parentSignalMap : WeakMap<BaseSignal, Parents>
+getParents(signal) : Parents | undefined
+bindParent(signal, parentSignal, key) : void
+unbindParent(signal, parentSignal, key) : void
+hasParent(signal, parentSignal, key) : boolean
+notifyParent(signal) : void
+notifySubscribers(signal, property, notifyParent) : void
}
class Parents {
<<type>>
Map<BaseSignal, Set<AnyKey>>
}
SignalManager --> Parents : "使用"
```

**中文(中文)**
- [manager.ts](file://packages/responsive/src/signal/manager.ts#L17-L123)

### 通知传播机制
信号管理器实现递归通知机制，当子信号更新时，不仅通知其订阅者，还递归通知所有父级信号。

```mermaid
sequenceDiagram
participant Child as "子信号"
participant Manager as "SignalManager"
participant Parent as "父信号"
participant SubManager as "SubManager"
Child->>Manager : notifySubscribers
Manager->>SubManager : notify(子信号)
Manager->>Manager : notifyParent(子信号)
Manager->>Manager : getParents(子信号)
loop 每个父级信号
Manager->>SubManager : notify(父信号)
Manager->>Manager : notifyParent(父信号)
end
```

**中文(中文)**
- [manager.ts](file://packages/responsive/src/signal/manager.ts#L95-L103)

## 结论
vitarx响应式系统通过精心设计的API和底层机制，实现了高效、灵活的响应式编程模型。系统采用Proxy实现深层响应式，通过依赖收集和副作用触发机制实现自动更新，利用三阶段调度器优化更新性能。`SignalManager`作为全局协调者，有效管理信号间的父子关系和通知传播。该系统不仅提供了基本的响应式功能，还支持浅层响应式、自定义比较函数等高级特性，满足不同场景的需求。